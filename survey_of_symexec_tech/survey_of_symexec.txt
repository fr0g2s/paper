많은 보안/sw 테스팅 앱은 가능한 사용 시나리오에 대해 이상이 없는지 확인해야함.
예를 들면, 인증을 우회할 수 있는 백도어 프로그램이 있는지.

이를 위한 한 가지 방법으로는 프로그램을 가능한 랜덤한 입력으로 테스트 해보는 것.
백도어가 특정 흐름에서 발동할 수 있으므로 가능한 모든 부분을 탐색하는게 중요.

심볼 실행은 이 문제에 대해 우아한 해결책을 제공함. 
심볼 실행은 체계적으로 가능한 실행 경로를 동시간대에, 정확한 입력값 없이 탐색 가능.

구체적인 값을 넣는것 보다 추상적인 심볼을 사용. 그리고 제약 조건 솔버(constraint solver)에 의존.
위반 사항(backdoor..)을 찾기 위해 "구체적인 값을 넣는것" 보다 "추상적인 심볼과 제약 조건 솔버(constraint solver)"를 사용.

이 논문은 심볼 실행의 메인 아이디어, 과제, 이에 대한 개발된 해결책을 제시함.


1. 소개
심볼 실행은 1970년대 중반에 소개된 유명한 프로그램 분석 기술임.
소프트웨어의 속성을 이용해 위반할 수 있는지 테스트하기 위한 목적을 가지고 있음.
"위반"이라 하면 0으로 나누기, null 포인터 역참조, 인증을 우회하는 백도어 등이 있음.

일반적으로 이를 확인하는 자동화 방법은 없지만, 휴리스틱과 근사치 분석(approximate analyses)은 유용할 수 있음.

concrete 실행에서는 특정 값을 넣어서 프로그램을 실행함. 한 경우의 control flow만 탐색함.
이 방법은 우리 관심분야(0으로 나누기, 백도어, null 포인터 역참조..) 분석을 근사치로만 평가할 수 있음. 신뢰성이 떨어진다는 뜻.
반면에 symbolic 실행은 (=심볼 실행) 다른 입력을 통해 여러 경우의 control flow를 탐색할 수 있음. 신뢰성이 올라감.
주요 아이디어는 프로그램이 symbolic한 입력을 가질 수 있게하는 것.
심볼 실행 엔진을 통해 실행하면 가능함.
다음과 같은 요소를 가지고 있음.

- 부울 공식: 해당 경로를 타기 위해서 필요한 조건을 나타냄. ( a>0 && b<0 ... )
- 심볼 메모리 저장소: 심볼 변수나 값을 저장하고 있음. 
"분기 실행"은 공식을 업데이트하고, "할당"은 기호 저장소를 업데이트함.
분기실행: jump, goto...
할당: 변수에 값 할당, 연산...

model checker는 SMT solver 기반으로, 부울 공식을 만족하는 해를 찾음. 이걸로 해당 경로가 실현 가능한지 증명함.
(= 부울 공식에 구체적인 값을 넣어서 해당 식을 만족하는지 여부를 확인. 그리고 이 작업에 SMT solver라는 흑마법이 쓰임.)
' 대충 심볼 실행이 의미 있는 연구라는걸 뒷받침하는 자료들 '
간단한 예제로 시작해보자.

1.1 워밍업
---------------------------------
void foobar(int a, int b) {
	int x=1, y=0;
	if (a != 0){
		y = x+3;
		if (b == 0)
			x = (a+b)*2;
	}
	assert(x-y != 0);	
}
---------------------------------
* assert()안에 있는 조건이 false라면, 에러가 발생하고 프로그램이 멈춤. 우린 에러가 발생하기 위한 x,y 값을 심볼 실행 과정을 통해 찾을 것임.

인자로 받는 4바이트 정수형 변수는 2^32 경우를 가질 수 있어서 구체적인 값을 랜덤생성하여 넣으면서 테스트하는건 무리.
심볼 실행은 이 한계를 이겨내고 단일 입력값이 아닌 "입력 클래스"를 추론할 수 있음. (입력 클래스가 뭔지 모르겠음..)

좀 더 세부적으로, 모든 값은 코드 정적 분석으로는 알지 못함. 함수 인자나 스트림으로부터 데이터를 읽는 syscall의 결과 등..
이런것들은 심볼 α(알파)로 나타냄.

심볼 실행 엔진은 항상 state(stmt, σ, π)을 유지하고 있음.

- stmt: 평가할 다음 statement. 한동안 stmt는 "할당", "조건 분기", "분기" 이렇게 3가지만 있다고 가정. 더 복잡한건 나중에 나옴
- σ(시그마): 심볼 저장소. 구체적인 값이나 심볼 변수 α가 저장됨.
- π(파이): 경로 조건을 부울 공식으로 나타냄. 해당 stmt에 접근하기 위해 만족해야하는 조건이 α를 섞은 식으로 나타나있음.
		   처음에는 π=ture

stmt에 따라 심볼 엔진은 다음 작동을 함.
		- 할당: σ를 업데이트함. 어떤 값을 할당했는지 저장.
		- 조건 분기: π를 업데이트함. 심볼실행은 if를 만나면 if then과 else로 경로를 나누어서 실행함.
					이 때 if then이 되기위한 조건과 else가 되기위한 조건을 π에 추가함. 조건은 심볼 변수가 사용될 수도, 상수가 사용될 수도 있음.
		- 분기: smtm를 업데이트함. stmt를 점프한 곳의 stmt로 업데이트.

함수 foobar()를 심볼 실행 과정을 tree로 표현하는게 효과적임. (그림은 논문 Figure 2.)

assert() 함수에 진입하면 그동안 저장된 모든 경로의 부울 공식을 SMT solver로 해결.
결과를 분석하면, x-y=0이 되는 경우를 찾을 수 있음. a=2, b=0


1.2 심볼 실행의 과제
이전 단락에서는 심볼 실행을 통해 "모든" 가능한 인풋중 assert fail이 되는 경우를 찾는 과정을 살펴봤음.
이것은 가능성 있는 실행 경로를 철저한 탐색을 통해 이루어짐.
철저한 탐색은 모든 경로를 보는데, 덕분에 false positives(거짓 양성)을 방지함.
근데 이 철저한 탐색은 소규모의 앱 이상으로 확장하기가 힘듦. 
성능과 정확성을 trade off 해야함.

real world에서의 심볼 실행은 위에서 봤던 예제보다 훨신 더 복잡함. 그리고 자연스레 질문이 생기게됨.

- Memory: 심볼 엔진은 어떻게 포인터, 배열 및 또다른 복잡한 객체들을 다루는가?
		  포인터와 데이터 구조를 조작하는 코드는 심볼 데이터 뿐만 아니라 기호식으로 설명되는 주소를 생성할 수 있다.
- Environtment: 심볼 실행 엔진은 어떻게 소프트웨어 스택과 상호작용하나?
				라이브러리를 호출하거나 시스템 코드를 호출하는건 부작용을 일으킬 수 있음.
				예를 들어, 파일을 만들거나 사용자 코드로 콜백하거나.. 이런건 나중에 실행에 영향을 미칠 수 있음.
				그러나 어떤 상호작용을 하는지 아는것은 불가능할 수 있음.
- Constraint solving: 제약 솔버는 실제로 무엇을 할수 있는가?
					  SMT solver는 수백 개의 변수에 대한 복잡한 제약 조합도 가능.
					  그러나 비선형 산술(?)과 같은 구조는 효율성에 큰 장애물.


심볼 실행이 사용되는 특정 context에 따라 위 질문을 해결하기 위해 다양한 선택과 전제가 이루어짐.
이러한 선택은 결과의 신뢰도와 완전성에 영향을 미침.
하지만 모든 경우를 탐색하는 것보다 부분적으로만 탐색하면 제한된 자원만으로도 목표(crash를 발생시키는 입력값 등)를 달성할 수 있음.





1.3 관련 작업
-
1.4 논문의 나머지 구성
섹션2에서는 심볼 실행의 전반적인 원칙과 평가 전략.
섹션3부터 섹션6까지는 섹션1.2에서 말한것들.
섹션7에서는 심볼 실행 기술을 향상시키기 위해 다른 영역의 최근 기술을 적용할 수있는 방법.
섹션8은 결론.

------------------------------------------------------------------------------------------------------------------------------

2. 심볼 실행 엔진
이 장에서는 심볼 executors 디자인에 대한 몇 가지 중요한 원칙과, 구현에서 발생하는 중요한 trade-off를 설명.
concrete와 symbolic 실행에서 벗어나 concolic 실행에 대해서도 소개함.

2.1 symbolic + concrete
섹션 1.1의 예제에서 봤듯이, 심볼 실행은 모든 가능한 제어 흐름 경로를 만드는게 가능.
모든 가능한 경로를 모델링하는 것은 매우 흥미로운 분석이 가능하지만, 실제 소프트웨어에서는 실행 불가능.
전통적인 심볼 실행의 주요 한계는 solving 불가능한 경로도 탐색한다는 것.
신뢰도 손실은 심볼 executor가 추적할 수 없는 외부 코드와 관련된 복잡한 제약에서 비롯됨.
(비선형 산술 또는 초월함수 등) *초월 함수: 다항식의 근으로 정의할 수 없는 함수.

제약 솔빙에 소요되는 시간이 엔진의 주요 성능 장벽임. 그래서 해결 가능성과 효율성은 중요함.

실제 프로그램은 대부분 독립적이지 않음.
소프트웨어 스택을 정적 분석할 수있는 심볼 엔진을 구현하는 것은, 런타임에서 발생할 수있는 부작용을 알기 어렵기 때문에 구현이 힘듦.

이 이슈를 대처하는 기본적은 아이디어와 심볼 실행을 리얼 월드에서 실현가능하게 만들기 위해서는 concrete 실행과 섞는 것.
이를 concolic(CONCrete + symbOLIC) 실행이라고 부름.
이 일반적은 원칙은 남은 섹션에서 다른 각도로 알아볼것임.


Dynamic Symbolic Execution = Dynamic test generation = DSE.
concolic 실행의 유명한 접근 방법 중 하나인 DSE는, 콘크리트 실행으로 심볼 실행을 유도하는 것. 
이 기술은 효과적으로 위의 문제(현실적으로 힘들다는 문제)를 완화시킬 수 있음.
심볼 저장소, 경로 조건, 실행 엔진은 concrete store(σc: 시그마c)를 가지고있음.

임의의 시작값을 정한 후, 두 개의 저장소(시그마, 시그마c)와 경로 조건을 동시에 업데이트하여 구체적이고 심볼릭하게 프로그램을 실행함.
콘크리트 실행이 분기를 가지게 되면, 심볼 실행은 같은 지점을 향하고 분기 조건에서 제약조건을 추출하여 경로 제약 집합에 추가함.
간단히 말해서, 심볼 실행은 특정 콘크리트 실행에 의해 동작함.
심볼 엔진은 분기 조건이 만족할 수 있는지 결정하기위해 제약 조건 솔버를 사용하지 않아도 됨. (콘크리트 실행으로 테스트 했었으니)
다른 경로를 탐사하기 위해 경로 조건은 하나 이상의 분기가 제공하는 경로 조건을 무시 가능.
그리고 SMT solver를 호출하여 새로운 제약 조건을 만족하는 값을 찾을 수 있음.
이 전략은 원하는 범위를 달성할 때까지 반복가능.

예제.
섹션 1의 Figure 1에 있는 foobar 함수에 a=1, b=1을 준다고 하자.
이 조건에서 콘크리트 실행은 A->B->C->E->G 경로를 가진다.
Figure2의 심볼 저장소외에도 콘크리트 저장소는 탐색했던 상태를 유지한다.
σc = {a->1, b->1} , σc = {a->1, b->1, x->1, y->0} σc = {a->1, b->1, x->1, y->4}

8번 라인에서 assert() 조건(x-y != 0)을 만족한다면, 우리는 새로운 제어 흐름 경로를 만들 수 있다.
어떻게? 마지막 3번째 경로 제약 조건을 부정함으로서. b!=0 를 b=0 으로 만드는 것 처럼.
솔버는 이 때 a!=0 && b=0 의 조건을 만족하는 새로운 입력값을 생성한다.
그럼 A->B->C->E->F 의 경로를 탐사할 것이다.



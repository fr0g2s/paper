많은 보안/sw 테스팅 앱은 가능한 사용 시나리오에 대해 이상이 없는지 확인해야함.
예를 들면, 인증을 우회할 수 있는 백도어 프로그램이 있는지.

이를 위한 한 가지 방법으로는 프로그램을 가능한 랜덤한 입력으로 테스트 해보는 것.
백도어가 특정 흐름에서 발동할 수 있으므로 가능한 모든 부분을 탐색하는게 중요.

심볼 실행은 이 문제에 대해 우아한 해결책을 제공함. 
심볼 실행은 체계적으로 가능한 실행 경로를 동시간대에, 정확한 입력값 없이 탐색 가능.

구체적인 값을 넣는것 보다 추상적인 심볼을 사용. 그리고 제약 조건 솔버(constraint solver)에 의존.
위반 사항(backdoor..)을 찾기 위해 "구체적인 값을 넣는것" 보다 "추상적인 심볼과 제약 조건 솔버(constraint solver)"를 사용.

이 논문은 심볼 실행의 메인 아이디어, 과제, 이에 대한 개발된 해결책을 제시함.


1. 소개
심볼 실행은 1970년대 중반에 소개된 유명한 프로그램 분석 기술임.
소프트웨어의 속성을 이용해 위반할 수 있는지 테스트하기 위한 목적을 가지고 있음.
"위반"이라 하면 0으로 나누기, null 포인터 역참조, 인증을 우회하는 백도어 등이 있음.

일반적으로 이를 확인하는 자동화 방법은 없지만, 휴리스틱과 근사치 분석(approximate analyses)은 유용할 수 있음.

concrete 실행에서는 특정 값을 넣어서 프로그램을 실행함. 한 경우의 control flow만 탐색함.
이 방법은 우리 관심분야(0으로 나누기, 백도어, null 포인터 역참조..) 분석을 근사치로만 평가할 수 있음. 신뢰성이 떨어진다는 뜻.
반면에 symbolic 실행은 (=심볼 실행) 다른 입력을 통해 여러 경우의 control flow를 탐색할 수 있음. 신뢰성이 올라감.
주요 아이디어는 프로그램이 symbolic한 입력을 가질 수 있게하는 것.
심볼 실행 엔진을 통해 실행하면 가능함.
다음과 같은 요소를 가지고 있음.

- 부울 공식: 해당 경로를 타기 위해서 필요한 조건을 나타냄. ( a>0 && b<0 ... )
- 심볼 메모리 저장소: 심볼 변수나 값을 저장하고 있음. 
"분기 실행"은 공식을 업데이트하고, "할당"은 기호 저장소를 업데이트함.
분기실행: jump, goto...
할당: 변수에 값 할당, 연산...

model checker는 SMT solver 기반으로, 부울 공식을 만족하는 해를 찾음. 이걸로 해당 경로가 실현 가능한지 증명함.
(= 부울 공식에 구체적인 값을 넣어서 해당 식을 만족하는지 여부를 확인. 그리고 이 작업에 SMT solver라는 흑마법이 쓰임.)
' 대충 심볼 실행이 의미 있는 연구라는걸 뒷받침하는 자료들 '
간단한 예제로 시작해보자.

1.1 워밍업
---------------------------------
void foobar(int a, int b) {
	int x=1, y=0;
	if (a != 0){
		y = x+3;
		if (b == 0)
			x = (a+b)*2;
	}
	assert(x-y != 0);	
}
---------------------------------
* assert()안에 있는 조건이 false라면, 에러가 발생하고 프로그램이 멈춤. 우린 에러가 발생하기 위한 x,y 값을 심볼 실행 과정을 통해 찾을 것임.

인자로 받는 4바이트 정수형 변수는 2^32 경우를 가질 수 있어서 구체적인 값을 랜덤생성하여 넣으면서 테스트하는건 무리.
심볼 실행은 이 한계를 이겨내고 단일 입력값이 아닌 "입력 클래스"를 추론할 수 있음. (입력 클래스가 뭔지 모르겠음..)

좀 더 세부적으로, 모든 값은 코드 정적 분석으로는 알지 못함. 함수 인자나 스트림으로부터 데이터를 읽는 syscall의 결과 등..
이런것들은 심볼 α(알파)로 나타냄.

심볼 실행 엔진은 항상 state(stmt, σ, π)을 유지하고 있음.

- stmt: 평가할 다음 statement. 한동안 stmt는 "할당", "조건 분기", "분기" 이렇게 3가지만 있다고 가정. 더 복잡한건 나중에 나옴
- σ(시그마): 심볼 저장소. 구체적인 값이나 심볼 변수 α가 저장됨.
- π(파이): 경로 조건을 부울 공식으로 나타냄. 해당 stmt에 접근하기 위해 만족해야하는 조건이 α를 섞은 식으로 나타나있음.
		   처음에는 π=ture

stmt에 따라 심볼 엔진은 다음 작동을 함.
		- 할당: σ를 업데이트함. 어떤 값을 할당했는지 저장.
		- 조건 분기: π를 업데이트함. 심볼실행은 if를 만나면 if then과 else로 경로를 나누어서 실행함.
					이 때 if then이 되기위한 조건과 else가 되기위한 조건을 π에 추가함. 조건은 심볼 변수가 사용될 수도, 상수가 사용될 수도 있음.
		- 분기: smtm를 업데이트함. stmt를 점프한 곳의 stmt로 업데이트.

함수 foobar()를 심볼 실행 과정을 tree로 표현하는게 효과적임. (그림은 논문 Figure 2.)

assert() 함수에 진입하면 그동안 저장된 모든 경로의 부울 공식을 SMT solver로 해결.
결과를 분석하면, x-y=0이 되는 경우를 찾을 수 있음. a=2, b=0


1.2 심볼 실행의 과제
이전 단락에서는 심볼 실행을 통해 "모든" 가능한 인풋중 assert fail이 되는 경우를 찾는 과정을 살펴봤음.
이것은 가능성 있는 실행 경로를 철저한 탐색을 통해 이루어짐.
철저한 탐색은 모든 경로를 보는데, 덕분에 false positives(거짓 양성)을 방지함.
근데 이 철저한 탐색은 소규모의 앱 이상으로 확장하기가 힘듦. 
성능과 정확성을 trade off 해야함.

real world에서의 심볼 실행은 위에서 봤던 예제보다 훨신 더 복잡함. 그리고 자연스레 질문이 생기게됨.

- Memory: 심볼 엔진은 어떻게 포인터, 배열 및 또다른 복잡한 객체들을 다루는가?
		  포인터와 데이터 구조를 조작하는 코드는 심볼 데이터 뿐만 아니라 기호식으로 설명되는 주소를 생성할 수 있다.
- Environtment: 심볼 실행 엔진은 어떻게 소프트웨어 스택과 상호작용하나?
				라이브러리를 호출하거나 시스템 코드를 호출하는건 부작용을 일으킬 수 있음.
				예를 들어, 파일을 만들거나 사용자 코드로 콜백하거나.. 이런건 나중에 실행에 영향을 미칠 수 있음.
				그러나 어떤 상호작용을 하는지 아는것은 불가능할 수 있음.
- Constraint solving: 제약 솔버는 실제로 무엇을 할수 있는가?
					  SMT solver는 수백 개의 변수에 대한 복잡한 제약 조합도 가능.
					  그러나 비선형 산술(?)과 같은 구조는 효율성에 큰 장애물.


심볼 실행이 사용되는 특정 context에 따라 위 질문을 해결하기 위해 다양한 선택과 전제가 이루어짐.
이러한 선택은 결과의 신뢰도와 완전성에 영향을 미침.
하지만 모든 경우를 탐색하는 것보다 부분적으로만 탐색하면 제한된 자원만으로도 목표(crash를 발생시키는 입력값 등)를 달성할 수 있음.





1.3 관련 작업
-
1.4 논문의 나머지 구성
섹션2에서는 심볼 실행의 전반적인 원칙과 평가 전략.
섹션3부터 섹션6까지는 섹션1.2에서 말한것들.
섹션7에서는 심볼 실행 기술을 향상시키기 위해 다른 영역의 최근 기술을 적용할 수있는 방법.
섹션8은 결론.

------------------------------------------------------------------------------------------------------------------------------

2. 심볼 실행 엔진
이 장에서는 심볼 executors 디자인에 대한 몇 가지 중요한 원칙과, 구현에서 발생하는 중요한 trade-off를 설명.
concrete와 symbolic 실행에서 벗어나 concolic 실행에 대해서도 소개함.

2.1 symbolic + concrete
섹션 1.1의 예제에서 봤듯이, 심볼 실행은 모든 가능한 제어 흐름 경로를 만드는게 가능.
모든 가능한 경로를 모델링하는 것은 매우 흥미로운 분석이 가능하지만, 실제 소프트웨어에서는 실행 불가능.
전통적인 심볼 실행의 주요 한계는 solving 불가능한 경로도 탐색한다는 것.
신뢰도 손실은 심볼 executor가 추적할 수 없는 외부 코드와 관련된 복잡한 제약에서 비롯됨.
(비선형 산술 또는 초월함수 등) *초월 함수: 다항식의 근으로 정의할 수 없는 함수.

제약 솔빙에 소요되는 시간이 엔진의 주요 성능 장벽임. 그래서 해결 가능성과 효율성은 중요함.

실제 프로그램은 대부분 독립적이지 않음.
소프트웨어 스택을 정적 분석할 수있는 심볼 엔진을 구현하는 것은, 런타임에서 발생할 수있는 부작용을 알기 어렵기 때문에 구현이 힘듦.

이 이슈를 대처하는 기본적은 아이디어와 심볼 실행을 리얼 월드에서 실현가능하게 만들기 위해서는 concrete 실행과 섞는 것.
이를 concolic(CONCrete + symbOLIC) 실행이라고 부름.
이 일반적은 원칙은 남은 섹션에서 다른 각도로 알아볼것임.


Dynamic Symbolic Execution = Dynamic test generation = DSE.
concolic 실행의 유명한 접근 방법 중 하나인 DSE는, 콘크리트 실행으로 심볼 실행을 유도하는 것. 
이 기술은 효과적으로 위의 문제(현실적으로 힘들다는 문제)를 완화시킬 수 있음.
심볼 저장소, 경로 조건, 실행 엔진은 concrete store(σc: 시그마c)를 가지고있음.

임의의 시작값을 정한 후, 두 개의 저장소(시그마, 시그마c)와 경로 조건을 동시에 업데이트하여 구체적이고 심볼릭하게 프로그램을 실행함.
콘크리트 실행이 분기를 가지게 되면, 심볼 실행은 같은 지점을 향하고 분기 조건에서 제약조건을 추출하여 경로 제약 집합에 추가함.
간단히 말해서, 심볼 실행은 특정 콘크리트 실행에 의해 동작함.
심볼 엔진은 분기 조건이 만족할 수 있는지 결정하기위해 제약 조건 솔버를 사용하지 않아도 됨. (콘크리트 실행으로 테스트 했었으니)
다른 경로를 탐사하기 위해 경로 조건은 하나 이상의 분기가 제공하는 경로 조건을 무시 가능.
그리고 SMT solver를 호출하여 새로운 제약 조건을 만족하는 값을 찾을 수 있음.
이 전략은 원하는 범위를 달성할 때까지 반복가능.

Example.
섹션 1의 Figure 1에 있는 foobar 함수에 a=1, b=1을 준다고 하자.
이 조건에서 콘크리트 실행은 A->B->C->E->G 경로를 가진다.
Figure2의 심볼 저장소외에도 콘크리트 저장소는 탐색했던 상태를 유지한다.
σc = {a->1, b->1} , σc = {a->1, b->1, x->1, y->0} σc = {a->1, b->1, x->1, y->4}

8번 라인에서 assert() 조건(x-y != 0)을 만족한다면, 우리는 새로운 제어 흐름 경로를 만들 수 있다.
어떻게? 마지막 3번째 경로 제약 조건을 부정함으로서. b!=0 를 b=0 으로 만드는 것 처럼.
솔버는 이 때 a!=0 && b=0 의 조건을 만족하는 새로운 입력값을 생성한다.
그럼 A->B->C->E->F 의 경로를 탐사할 것이다.
end of Example

DSE는 구체적인 입력값을 통해서 특정 경로로 심볼 실행을 유도하지만, 새 경로를 탐색해야 할 때마다 부정 할 분기를 선택해야한다. (가기 싫은 곳은 걸러야 한다)
또한 각각의 콘크리트 실행은 방문해야할 새 분기를 추가할 수 있다.
모든 콘크리트 실행에 걸쳐 가보지 않은 분기 집합이 매우 클 수 있고, 효과적인 검색 휴리스틱을 선택하는 것이 중요한 역할을 할 수 있다.
예를 들어, DART (Directed Automated Random Testing)는 깊이 우선 전략을 사용하여 부정할 다음 분기를 선택한다.
예를 들어 generational search of SAGE 방법은 체계적이지만, 부분적으로 상태 공간을 탐색하여, 생성된 테스트의 수를 최대화하는 동시에 검색의 중복을 방지한다.
이 방법은 특정 순서를 따르는 제약 조건을 무효화하고, 검색 알고리즘의 역추적을 제한함으로써 달성한다.
상태 공간이 특정 부분만 탐사되므로, 초기 인풋은 전체 접근 방식의 효율성에 중요한 역할을 한다.
첫 입력값의 중요성은 전통적인 블랙박스 퍼징에서 발생하는 것과 유사하다. 게다가 SAGE와 같은 심볼 엔진은 화이트박스 퍼저라고 지칭된다.

콘크리트 실행 중에 유지되는 기호 정보는 엔진에서 새로운 입력을 얻고, 새로운 경로를 탐색하는데 이용될 수 있다.
다음 예제는 concolic 엔진이 기호적으로 추적하지 않는 외부 코드에 대한 호출을 DSE가 처리하는 방법을 보여준다.
제약 해결에 사용되는 구체적인 값의 사용은 섹션6에서 설명한다.


Example.
Fig 4.
(a)                             (b)                             (c)
void foo (int x, int y){        void qux(int x){                void baz(int x){
    int a = bar(x);                 int a = bar(x);                 abs(&x);
    if (y < 0) ERROR;               if (a>0) ERROR;                 if (x < 0) ERROR;
}                               }                               }

(a): bar 함수가 추적 불가능 할 때, foo 함수 테스트
(b): false negative 예시
(c): 경로 발산에 대한 예시. abs는 x의 부호를 삭제한다.

Fig4a.
foo 함수를 고려하고 bar함수가 concolic engine에 의해 심볼릭 추적이 안된다고 가정해보자. (3rd-party 제품이거나 블랙 박스 방식을 따르는 분석 등)
x=1, y=2 가 초기 인풋으로 무작위 선택되었다고 가정해보자.
concolic 엔진은 bar를 실행(0을 리턴하는)하고 에러 상태가 발생하는 분기를 건너뛴다.
동시에, 심볼 실행은 foo함수의 y>=0 경로 제약 조건을 추적한다.
bar 함수 안에 있는 분기 제약 조건은 엔진으로 알지 못한다는걸 주의해라.
대체 경로를 탐색하기 위해(다른 길도 알아보기위해), 엔진은 foo의 경로 제약 조건을 부정하고, x=1,y=-4 같은 입력을 생성하여 대체 경로로 콘크리트 실행을 유도한다.

Fig4b.
Fig4a를 조금 바꿨다.
qux함수는 하나의 인풋을 받고, bar 함수의 리턴값도 검사한다.
엔진이 qux의 분기 조건 테스트에서 경로 제약조건을 추적할수 있긴 하지만, 대체 경로로 실행을 유도할 수 있는 입력이 생성된다는 보장은 없다.
(bar 함수가 심볼릭 추적이 안되기 때문에 a와 x의 관계가 concolic 엔진은 모르기 때문)
이 경우, 엔진은 다른 랜덤 인풋으로 코드를 다시 실행할 수 있지만, 마지막에는 qux의 흥미로운 경로하나는 탐색하지 못할것이다.

Fig4c.
관련 문제는 여기 나와있다.
우리는 예측경로에 대해 생성된 입력이 실행을 다른 경로로 이끄는 경우, path divergence(경로 발산)이 관찰된다.
보통, 이 경우 심볼 전파가 추적되지 않거나, 부정확한 경로 제약조건 결과가 나오거나, 엔진에서 특정 작업을 모델링할 때 부정확성의 원인이 된다.
예시로, baz 함수는 x에 절대값을 부여하며 부작용을 일으키는 외부 함수 abs를 실행한다.
x=1을 초기값으로 선택하면, 콘크리트 실행은 error 코드를 실행하지 않는다.
하지만 concolic 엔진은 x>=0인 경로 제약 조건을 추적 및 부정하여 새로운 입력값을 생성하려고 한다.
그러나 새로운 입력값인 x=-1인 경우 abs 함수 때문에 error 코드를 실행하지 않는다.
흥미롭게도, 엔진은 이걸 발견할 방법이 없다.
end of Example

예제에서 봤듯이, false negatives 와 path divergences는 DSE의 주목할만한 단점이다.
DSE는 성능 및 구현을 위해 신뢰성을 희생한다.
특정 코드 실행이 누락되어 완전하지만, 대략적인 프로그램 분석 형식에 미치지 못하기 때문에 false negative가 가능하다.
경로 발산은 이 분야에서 자주 발견된다. 예를들어, [52] 보고서는 60%를 넘는다.
[27]보고서는 경로 발산에 대한 경험적 연구를 제공하고, 이 현상에 기여하는 주요 패턴을 분석한다.
외부 호출, 예외 처리, 타입 변환, 기호 포인터들은 concolic 실행시 경로 발산을 줄이기 위해 엔진이 신중히 처리해야하는 중요한 측면으로 지적된다.



